//
// Copyright © 2003-11. All rights reserved.
// Binachip, Inc.
// http://www.binachip.com
//
// Generated by :     ESLerate v3.00.00
//
// Date/Time :        Fri Jan 14 13:48:36 2011
//
// Legal Disclaimer : The use of this file is governed by the Binachip, Inc. Software License Agreement.
//


`timescale 1 ns / 1 ns

module sramb(clock, rd_addr, wr_addr, wr_en, dout, din);
	parameter signed [31:0] SRAMB_BUFFER_SIZE = 1024;
	parameter signed [31:0] SRAMB_ADDR_WIDTH = 10;
	parameter signed [31:0] SRAMB_DATA_WIDTH = 32;
	input wire clock;
	input wire [(SRAMB_ADDR_WIDTH - 1):0] rd_addr;
	input wire [(SRAMB_ADDR_WIDTH - 1):0] wr_addr;
	input wire wr_en;
	output wire [(SRAMB_DATA_WIDTH - 1):0] dout;
	input wire [(SRAMB_DATA_WIDTH - 1):0] din;
	reg [(SRAMB_DATA_WIDTH - 1):0] mem [0:(SRAMB_BUFFER_SIZE - 1)];
	reg [(SRAMB_ADDR_WIDTH - 1):0] read_addr = 1'h0;

	function [63:0] to01;
		input reg [63:0] val;
		integer i;
		reg [63:0] result;
		begin 
			for ( i = 0; i <= 63; i = i + 1 )
			begin 
				
				case (val[i])
					1'b0 : result[i] = 1'b0;

					1'b1 : result[i] = 1'b1;

					default : result[i] = 1'b0;

				endcase
			end
			to01 = result;
		end
	endfunction


	always @
	(
		posedge clock
	)
	begin : sramb_write_process
		if (clock == 1'b1) begin 
			if (wr_en == 1'h1) begin 
				mem[to01(wr_addr)] <= to01(din);
			end
			read_addr <= rd_addr;
		end
	end
	assign dout = to01(mem[to01(read_addr)]);

endmodule
