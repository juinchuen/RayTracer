//
// Copyright © 2003-11. All rights reserved.
// Binachip, Inc.
// http://www.binachip.com
//
// Generated by :     ESLerate v3.00.00
//
// Date/Time :        Fri Jan 14 13:48:36 2011
//
// Legal Disclaimer : The use of this file is governed by the Binachip, Inc. Software License Agreement.
//


`timescale 1 ns / 1 ns

module sram(clock, rd_addr, wr_addr, wr_en, dout, din);
	parameter signed [31:0] SRAM_BUFFER_SIZE = 1024;
	parameter signed [31:0] SRAM_DATA_WIDTH = 32;
	parameter signed [31:0] SRAM_ADDR_WIDTH = 10;
	input wire clock;
	input wire [(SRAM_ADDR_WIDTH - 1):0] rd_addr;
	input wire [(SRAM_ADDR_WIDTH - 1):0] wr_addr;
	input wire [((SRAM_DATA_WIDTH / 8) - 1):0] wr_en;
	output wire [(SRAM_DATA_WIDTH - 1):0] dout;
	input wire [(SRAM_DATA_WIDTH - 1):0] din;
	localparam signed [31:0] NUM_BYTES = SRAM_DATA_WIDTH / 8;
	localparam signed [31:0] SELECT_BITS = log2(NUM_BYTES);
	localparam signed [31:0] SRAMB_ADDR_WIDTH = (SRAM_ADDR_WIDTH > SELECT_BITS) ? (SRAM_ADDR_WIDTH - SELECT_BITS) : SRAM_ADDR_WIDTH;
	localparam signed [31:0] SRAMB_BUFFER_SIZE = SRAM_BUFFER_SIZE / NUM_BYTES;

	function integer log2;
		input integer val;
		integer tmp;
		begin 
			tmp = val;
			for ( log2 = 0; tmp > 1; log2 = log2 + 1 )
			begin 
				tmp = tmp >> 1;
			end
			if ((val != 0) && ((1 << log2) != val)) log2 = log2 + 1;
		end
	endfunction


	generate
		genvar i;

		for ( i = 0; i < NUM_BYTES; i = i + 1 )
		begin : sram_block
			sramb
			#(.SRAMB_BUFFER_SIZE(SRAMB_BUFFER_SIZE),
			  .SRAMB_ADDR_WIDTH(SRAMB_ADDR_WIDTH),
			  .SRAMB_DATA_WIDTH(8))
			sramb_instance 
			(
				.clock(clock),
				.din(din[(8 * i)+:8]),
				.rd_addr(rd_addr[(SRAM_ADDR_WIDTH - 1):(SRAM_ADDR_WIDTH - SRAMB_ADDR_WIDTH)]),
				.wr_addr(wr_addr[(SRAM_ADDR_WIDTH - 1):(SRAM_ADDR_WIDTH - SRAMB_ADDR_WIDTH)]),
				.wr_en(wr_en[i]),
				.dout(dout[(8 * i)+:8])
			);
		end
	endgenerate

endmodule
